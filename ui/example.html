<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Chatbot Y Khoa Streaming</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body { 
  font-family: Arial, sans-serif; 
  background: #f0f2f5; 
  margin: 0; 
  padding: 0; 
}

#chatIcon { 
  position: fixed; 
  bottom: 20px; 
  right: 20px; 
  width: 60px; 
  height: 60px; 
  border-radius: 50%; 
  background: #0078FF; 
  color: white; 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  font-size: 30px; 
  cursor: pointer; 
  z-index: 1001;
  box-shadow: 0 4px 12px rgba(0,120,255,0.3);
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

#chatIcon:hover { 
  background: #005FCC; 
  transform: scale(1.05); 
}

#chatPopup { 
  position: fixed; 
  bottom: 90px; 
  right: 20px; 
  width: 360px; 
  height: 520px; 
  background: #fff; 
  border-radius: 16px; 
  box-shadow: 0 8px 32px rgba(0,0,0,0.15); 
  flex-direction: column; 
  overflow: hidden; 
  z-index: 1000;
  /* Initially hidden */
  display: none;
}

.chat-header { 
  background: #0078FF; 
  color: white; 
  padding: 15px; 
  text-align: center; 
  font-weight: bold; 
}

.chatbox { 
  flex: 1; 
  padding: 15px; 
  overflow-y: auto; 
  display: flex; 
  flex-direction: column; 
  background: #f8f9fa; 
}

.message { 
  display: flex; 
  margin-bottom: 12px; 
}

.message.bot { 
  justify-content: flex-start; 
}

.message.user { 
  justify-content: flex-end; 
}

.bubble { 
  max-width: 85%; 
  padding: 12px 16px; 
  border-radius: 18px; 
  word-wrap: break-word; 
  line-height: 1.4; 
}

.bot .bubble { 
  background: #ffffff; 
  border: 1px solid #e1e8ed; 
  color: #333; 
  box-shadow: 0 1px 2px rgba(0,0,0,0.1); 
}

.user .bubble { 
  background: linear-gradient(135deg, #0078FF, #00a8ff); 
  color: white; 
}

.chat-input { 
  display: flex; 
  border-top: 1px solid #e1e8ed; 
  padding: 10px; 
  background: white; 
}

.chat-input input { 
  flex: 1; 
  padding: 12px 16px; 
  border-radius: 24px; 
  border: 1px solid #e1e8ed; 
  font-size: 14px; 
  outline: none; 
}

.chat-input input:focus { 
  border-color: #0078FF; 
  box-shadow: 0 0 0 3px rgba(0,120,255,0.1); 
}

.chat-input button { 
  margin-left: 8px; 
  padding: 12px 16px; 
  border-radius: 50%; 
  border: none; 
  background: #0078FF; 
  color: white; 
  cursor: pointer; 
  transition: all 0.2s; 
}

.chat-input button:hover { 
  background: #005FCC; 
  transform: scale(1.05); 
}

.chat-input button:disabled { 
  background: #ccc; 
  cursor: not-allowed; 
  transform: none; 
}

/* Markdown Styles */
.bubble h1, .bubble h2, .bubble h3 { 
  margin: 8px 0 6px 0; 
  color: #1a73e8; 
  font-size: 16px; 
  font-weight: 600; 
}

.bubble h3 { 
  font-size: 15px; 
}

.bubble p { 
  margin: 6px 0; 
}

.bubble strong { 
  color: #1a73e8; 
  font-weight: 600; 
}

.bubble em { 
  color: #666; 
  font-style: italic; 
}

.bubble ul, .bubble ol { 
  margin: 8px 0; 
  padding-left: 20px; 
}

.bubble li { 
  margin: 3px 0; 
}

.bubble code { 
  background: #f1f3f4; 
  padding: 2px 4px; 
  border-radius: 3px; 
  font-family: monospace; 
  font-size: 13px; 
}

/* Reference Cards */
.reference-cards { 
  margin-top: 10px; 
}

.card { 
  border: 1px solid #e1e8ed; 
  border-radius: 12px; 
  padding: 12px; 
  margin: 8px 0; 
  background: #fff; 
  box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
  transition: all 0.2s; 
}

.card:hover { 
  box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
  transform: translateY(-1px); 
}

.card-title { 
  font-weight: 600; 
  color: #1a73e8; 
  margin-bottom: 6px; 
  font-size: 14px; 
}

.card-description { 
  color: #666; 
  font-size: 13px; 
  line-height: 1.4; 
  margin-bottom: 10px; 
}

.card-button { 
  padding: 8px 16px; 
  border-radius: 20px; 
  border: none; 
  background: #0078FF; 
  color: white; 
  cursor: pointer; 
  font-size: 12px; 
  font-weight: 500; 
  transition: all 0.2s; 
}

.card-button:hover { 
  background: #005FCC; 
  transform: scale(1.05); 
}

/* Loading Animation */
.typing-indicator { 
  display: flex; 
  align-items: center; 
  padding: 12px 16px; 
}

.typing-dots { 
  display: flex; 
  gap: 4px; 
}

.typing-dots div { 
  width: 6px; 
  height: 6px; 
  background: #999; 
  border-radius: 50%; 
  animation: typing 1.4s infinite; 
}

.typing-dots div:nth-child(2) { 
  animation-delay: 0.2s; 
}

.typing-dots div:nth-child(3) { 
  animation-delay: 0.4s; 
}

@keyframes typing { 
  0%, 60%, 100% { 
    transform: translateY(0); 
  } 
  30% { 
    transform: translateY(-10px); 
  } 
}

.streaming-text { 
  border-right: 2px solid #0078FF; 
  animation: blink 1s infinite; 
}

@keyframes blink { 
  0%, 50% { 
    border-color: transparent; 
  } 
  51%, 100% { 
    border-color: #0078FF; 
  } 
}
</style>
</head>
<body>

<div id="chatIcon">ü©∫</div>

<div id="chatPopup">
  <div class="chat-header">Chat SVY - Tr·ª£ l√Ω Y khoa</div>
  <div class="chatbox" id="chatbox"></div>
  <div class="chat-input">
    <input type="text" id="userInput" placeholder="Nh·∫≠p c√¢u h·ªèi y khoa...">
    <button id="sendBtn">‚û§</button>
  </div>
</div>

<script>
// Get DOM elements
const chatIcon = document.getElementById("chatIcon");
const chatPopup = document.getElementById("chatPopup");
const chatbox = document.getElementById("chatbox");
const userInput = document.getElementById("userInput");
const sendBtn = document.getElementById("sendBtn");

// State variables
let isStreaming = false;
let isOpen = false;

// Test function to verify everything is working
function testElements() {
  console.log('=== TESTING ELEMENTS ===');
  console.log('chatIcon:', chatIcon ? '‚úÖ Found' : '‚ùå Not found');
  console.log('chatPopup:', chatPopup ? '‚úÖ Found' : '‚ùå Not found');
  console.log('chatbox:', chatbox ? '‚úÖ Found' : '‚ùå Not found');
  console.log('userInput:', userInput ? '‚úÖ Found' : '‚ùå Not found');
  console.log('sendBtn:', sendBtn ? '‚úÖ Found' : '‚ùå Not found');
  console.log('========================');
}

// Simple toggle function
function toggleChat() {
  console.log('üîÑ Toggle clicked! Current state:', isOpen ? 'OPEN' : 'CLOSED');
  
  if (isOpen) {
    console.log('üì¥ Closing chat...');
    chatPopup.style.display = 'none';
    isOpen = false;
    console.log('‚úÖ Chat closed');
  } else {
    console.log('üì± Opening chat...');
    chatPopup.style.display = 'flex';
    isOpen = true;
    console.log('‚úÖ Chat opened');
    
    // Add welcome message if empty
    if (chatbox.children.length === 0) {
      console.log('üìù Adding welcome message...');
      addWelcomeMessage();
    }
    
    // Focus input
    setTimeout(() => {
      userInput.focus();
      console.log('üéØ Input focused');
    }, 100);
  }
}

// Add welcome message
function addWelcomeMessage() {
  const welcomeText = `Xin ch√†o! T√¥i l√† **Chat SVY** - tr·ª£ l√Ω ·∫£o v·ªÅ y khoa.

T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚Ä¢ T∆∞ v·∫•n v·ªÅ c√°c tri·ªáu ch·ª©ng b·ªánh l√Ω  
‚Ä¢ Cung c·∫•p th√¥ng tin ch·∫©n ƒëo√°n
‚Ä¢ ƒê·ªÅ xu·∫•t t√†i li·ªáu v√† kh√≥a h·ªçc y khoa

H√£y ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ t√¥i h·ªó tr·ª£ b·∫°n!`;
  
  addMessage(welcomeText, "bot", true);
  console.log('‚úÖ Welcome message added');
}

// Add message to chatbox
function addMessage(content, sender = "bot", isHTML = false) {
  const msg = document.createElement("div");
  msg.className = `message ${sender}`;
  
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  
  if (isHTML) {
    bubble.innerHTML = parseMarkdown(content);
  } else {
    bubble.textContent = content;
  }
  
  msg.appendChild(bubble);
  chatbox.appendChild(msg);
  chatbox.scrollTop = chatbox.scrollHeight;
  
  return bubble;
}

// Parse markdown
function parseMarkdown(text) {
  return text
    .replace(/### (.*$)/gm, '<h3>$1</h3>')
    .replace(/## (.*$)/gm, '<h2>$1</h2>')
    .replace(/# (.*$)/gm, '<h1>$1</h1>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/`(.*?)`/g, '<code>$1</code>')
    .replace(/‚Ä¢ (.*$)/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>')
    .replace(/^/, '<p>')
    .replace(/$/, '</p>')
    .replace(/<p><\/p>/g, '')
    .replace(/<p>(<ul>.*<\/ul>)<\/p>/g, '$1');
}

// Add typing indicator
function addTypingIndicator() {
  const msg = document.createElement("div");
  msg.className = "message bot";
  msg.id = "typing-indicator";
  
  const bubble = document.createElement("div");
  bubble.className = "bubble typing-indicator";
  bubble.innerHTML = '<div class="typing-dots"><div></div><div></div><div></div></div>';
  
  msg.appendChild(bubble);
  chatbox.appendChild(msg);
  chatbox.scrollTop = chatbox.scrollHeight;
  
  return msg;
}

// Remove typing indicator
function removeTypingIndicator() {
  const indicator = document.getElementById("typing-indicator");
  if (indicator) {
    indicator.remove();
  }
}

// Create reference card
function createReferenceCard(item) {
  const card = document.createElement("div");
  card.className = "card";
  
  const title = document.createElement("div");
  title.className = "card-title";
  title.textContent = item.title;
  
  const description = document.createElement("div");
  description.className = "card-description";
  description.textContent = item.description;
  
  const button = document.createElement("button");
  button.className = "card-button";
  button.textContent = getButtonText(item.tool);
  button.onclick = () => handleToolAction(item.tool, item.title);
  
  card.appendChild(title);
  card.appendChild(description);
  card.appendChild(button);
  
  return card;
}

// Get button text based on tool
function getButtonText(tool) {
  const buttonTexts = {
    "call_document": "üìÑ Xem t√†i li·ªáu",
    "call_cme": "üéì Tham gia kh√≥a h·ªçc", 
    "call_references": "üìö Xem tham kh·∫£o"
  };
  return buttonTexts[tool] || "üîó M·ªü";
}

// Handle tool action
function handleToolAction(tool, title) {
  const actions = {
    "call_document": () => alert(`üîç ƒêang t√¨m t√†i li·ªáu: ${title}\n\nCh·ª©c nƒÉng n√†y s·∫Ω m·ªü th∆∞ vi·ªán t√†i li·ªáu y khoa.`),
    "call_cme": () => alert(`üìñ ƒêang m·ªü kh√≥a h·ªçc: ${title}\n\nCh·ª©c nƒÉng n√†y s·∫Ω chuy·ªÉn ƒë·∫øn trang kh√≥a h·ªçc CME.`),
    "call_references": () => alert(`üìë ƒêang t·∫£i t√†i li·ªáu tham kh·∫£o: ${title}\n\nCh·ª©c nƒÉng n√†y s·∫Ω hi·ªÉn th·ªã c√°c t√†i li·ªáu li√™n quan.`)
  };
  
  (actions[tool] || (() => alert(`ƒêang x·ª≠ l√Ω: ${title}`)))();
}

// Extract text and JSON from response
function extractTextAndJSON(response) {
  const jsonStart = response.indexOf('{');
  const jsonEnd = response.lastIndexOf('}');
  
  if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
    const textPart = response.substring(0, jsonStart).trim();
    const jsonPart = response.substring(jsonStart, jsonEnd + 1);
    
    try {
      const jsonObj = JSON.parse(jsonPart);
      return { text: textPart, json: jsonObj };
    } catch (e) {
      console.log('JSON parse error:', e);
      return { text: response, json: null };
    }
  }
  
  return { text: response, json: null };
}

// Send message to API
async function sendMessage(userMessage) {
  if (isStreaming) return;
  
  console.log('üì§ Sending message:', userMessage);
  isStreaming = true;
  sendBtn.disabled = true;
  
  const typingIndicator = addTypingIndicator();
  
  try {
    console.log('üåê Calling API...');
    
    const requestBody = {
      prompt: userMessage
    };
    
    console.log('üìã Request body:', requestBody);
    
    // Try different approaches
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
    
    const response = await fetch('https://terms-founded-antibody-consequence.trycloudflare.com/model/generate/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json, text/plain, */*',
        'Origin': window.location.origin,
        'Referer': window.location.href
      },
      body: JSON.stringify(requestBody),
      mode: 'cors',
      credentials: 'omit',
      signal: controller.signal
    });

    clearTimeout(timeoutId);
    console.log('üì° API Response status:', response.status);
    console.log('üì° API Response headers:', Object.fromEntries(response.headers.entries()));

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå API Error response:', errorText);
      throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
    }

    removeTypingIndicator();

    // Check if response is streaming
    const contentType = response.headers.get('content-type');
    console.log('üìÑ Content-Type:', contentType);

    let fullResponse = '';
    const bubble = addMessage("", "bot");

    if (contentType && (contentType.includes('text/event-stream') || contentType.includes('text/stream'))) {
      console.log('üåä Handling streaming response...');
      
      // Handle streaming response
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          console.log('üì¶ Received chunk:', chunk);
          
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              if (data === '[DONE]' || data === '') continue;
              
              try {
                const parsed = JSON.parse(data);
                console.log('üìä Streaming data:', parsed);
                
                if (parsed.token || parsed.text || parsed.content || parsed.delta || parsed.choices?.[0]?.delta?.content) {
                  const token = parsed.token || parsed.text || parsed.content || parsed.delta || parsed.choices?.[0]?.delta?.content;
                  fullResponse += token;
                  bubble.innerHTML = parseMarkdown(fullResponse) + '<span class="streaming-text"></span>';
                  chatbox.scrollTop = chatbox.scrollHeight;
                }
              } catch (e) {
                console.log('üìù Plain text chunk:', data);
                // If not JSON, treat as plain text
                if (data.trim()) {
                  fullResponse += data;
                  bubble.innerHTML = parseMarkdown(fullResponse) + '<span class="streaming-text"></span>';
                  chatbox.scrollTop = chatbox.scrollHeight;
                }
              }
            }
          }
        }
      } catch (streamError) {
        console.error('‚ùå Streaming error:', streamError);
        if (fullResponse.trim()) {
          console.log('‚úÖ Using partial response from stream');
        } else {
          throw streamError;
        }
      }
      
      // Remove streaming cursor
      bubble.innerHTML = bubble.innerHTML.replace('<span class="streaming-text"></span>', '');
      
    } else {
      console.log('üìÑ Handling JSON response...');
      
      // Handle regular JSON response
      const responseText = await response.text();
      console.log('üìÑ Raw response:', responseText);
      
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.log('üìù Response is not JSON, treating as plain text');
        data = { response: responseText };
      }
      
      console.log('üìÑ Parsed response data:', data);
      
      fullResponse = data.response || data.message || data.text || data.output || data.generated_text || data.content || responseText || 'Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ server';
      
      // Simulate typing for better UX
      await simulateTyping(bubble, fullResponse);
    }
    
    // Process final response
    const { text, json } = extractTextAndJSON(fullResponse);
    bubble.innerHTML = parseMarkdown(text);
    
    // Add reference cards if JSON exists
    if (json) {
      const cardsContainer = document.createElement("div");
      cardsContainer.className = "reference-cards";
      cardsContainer.innerHTML = "<em>üìã T√†i li·ªáu tham kh·∫£o:</em>";
      
      Object.values(json).forEach(item => {
        if (item.title && item.description && item.tool) {
          cardsContainer.appendChild(createReferenceCard(item));
        }
      });
      
      bubble.appendChild(cardsContainer);
    }

    console.log('‚úÖ API call successful');

  } catch (error) {
    console.error('‚ùå API Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    
    removeTypingIndicator();
    
    // Different error messages based on error type
    let errorMessage = '';
    if (error.name === 'AbortError') {
      errorMessage = 'Timeout: API kh√¥ng ph·∫£n h·ªìi trong 30 gi√¢y';
    } else if (error.message.includes('Failed to fetch')) {
      errorMessage = 'Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API. C√≥ th·ªÉ do:\n‚Ä¢ CORS policy\n‚Ä¢ Network connectivity\n‚Ä¢ Server kh√¥ng ho·∫°t ƒë·ªông\n‚Ä¢ URL kh√¥ng ch√≠nh x√°c';
    } else if (error.message.includes('TypeError')) {
      errorMessage = 'L·ªói m·∫°ng ho·∫∑c server kh√¥ng kh·∫£ d·ª•ng';
    } else {
      errorMessage = error.message;
    }
    
    // Show detailed error message to user
    const errorBubble = addMessage("", "bot");
    errorBubble.innerHTML = `
      <p>‚ö†Ô∏è <strong>L·ªói k·∫øt n·ªëi API:</strong></p>
      <p style="color: #d32f2f; font-family: monospace; font-size: 12px; background: #ffebee; padding: 8px; border-radius: 4px; margin: 8px 0;">${errorMessage}</p>
      <p><em>ƒêang s·ª≠ d·ª•ng ph·∫£n h·ªìi m·∫´u...</em></p>
    `;
    
    // Wait a bit then show mock response
    setTimeout(async () => {
      const mockResponse = getMockResponse(userMessage);
      const { text, json } = extractTextAndJSON(mockResponse);
      
      const bubble = addMessage("", "bot");
      await simulateTyping(bubble, text);
      
      if (json) {
        const cardsContainer = document.createElement("div");
        cardsContainer.className = "reference-cards";
        cardsContainer.innerHTML = "<em>üìã T√†i li·ªáu tham kh·∫£o:</em>";
        
        Object.values(json).forEach(item => {
          if (item.title && item.description && item.tool) {
            cardsContainer.appendChild(createReferenceCard(item));
          }
        });
        
        bubble.appendChild(cardsContainer);
      }
    }, 1500);
    
  } finally {
    isStreaming = false;
    sendBtn.disabled = false;
  }
}

// Simulate typing effect
async function simulateTyping(bubble, text) {
  const words = text.split(' ');
  let currentText = '';
  
  for (let i = 0; i < words.length; i++) {
    currentText += words[i] + ' ';
    bubble.innerHTML = parseMarkdown(currentText.trim()) + '<span class="streaming-text"></span>';
    chatbox.scrollTop = chatbox.scrollHeight;
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  
  bubble.innerHTML = parseMarkdown(currentText.trim());
}

// Mock response for testing
function getMockResponse(userText) {
  const text = userText.toLowerCase();
  
  if (text.includes("j04.9") || text.includes("vi√™m ph·ªïi") || text.includes("virus")) {
    return `## M√£ b·ªánh: J04.9

### M√¥ t·∫£ b·ªánh
Vi√™m ph·ªïi do virus, kh√¥ng x√°c ƒë·ªãnh. T√¨nh tr·∫°ng vi√™m c·∫•p t√≠nh c·ªßa ph·ªïi do nhi·ªÖm virus, th∆∞·ªùng bi·ªÉu hi·ªán b·∫±ng ho, s·ªët cao v√† c√≥ th·ªÉ k√®m theo c√°c tri·ªáu ch·ª©ng kh√°c.

### Ch·∫©n ƒëo√°n
Vi√™m ph·ªïi c·∫•p do virus (J04.9). Ch·∫©n ƒëo√°n d·ª±a tr√™n c√°c tri·ªáu ch·ª©ng l√¢m s√†ng ƒëi·ªÉn h√¨nh nh∆∞ **ho d·ªØ d·ªôi**, **s·ªët cao li√™n t·ª•c** (th∆∞·ªùng tr√™n 38¬∞C), kh√≥ th·ªü, v√† c√≥ th·ªÉ k√®m theo c√°c d·∫•u hi·ªáu nhi·ªÖm tr√πng to√†n th√¢n.

### Tri·ªáu ch·ª©ng ch√≠nh
‚Ä¢ S·ªët cao li√™n t·ª•c (>38¬∞C)
‚Ä¢ Ho d·ªØ d·ªôi, kh√≥ th·ªü  
‚Ä¢ ƒêau ng·ª±c, ƒëau ƒë·∫ßu
‚Ä¢ M·ªát m·ªèi, ·ªõn l·∫°nh
‚Ä¢ S∆∞ng h·∫°ch c·ªï (>2cm)

{
    "document": {
        "title": "T√†i li·ªáu ch·∫©n ƒëo√°n vi√™m ph·ªïi virus", 
        "tool": "call_document",
        "description": "B√†i vi·∫øt cung c·∫•p th√¥ng tin chi ti·∫øt v·ªÅ tri·ªáu ch·ª©ng l√¢m s√†ng, ti√™u chu·∫©n ch·∫©n ƒëo√°n v√† ph∆∞∆°ng ph√°p x√©t nghi·ªám ph√¢n bi·ªát vi√™m ph·ªïi virus v·ªõi c√°c b·ªánh l√Ω kh√°c."
    },
    "cme": {
        "title": "Kh√≥a h·ªçc ch·∫©n ƒëo√°n vi√™m ph·ªïi",
        "tool": "call_cme",
        "description": "Kh√≥a h·ªçc t·∫≠p trung v√†o ph∆∞∆°ng ph√°p ch·∫©n ƒëo√°n ti√™n ti·∫øn cho vi√™m ph·ªïi c·∫•p do virus, bao g·ªìm nh·∫≠n di·ªán d·∫•u hi·ªáu l√¢m s√†ng v√† ph√¢n bi·ªát v·ªõi c√°c b·ªánh l√Ω kh√°c."
    }
}`;
  }

  if (text.includes("xin ch√†o") || text.includes("hello")) {
    return "Xin ch√†o! T√¥i l√† **Chat SVY** - tr·ª£ l√Ω ·∫£o y khoa. T√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n v·ªÅ:\n\n‚Ä¢ T∆∞ v·∫•n tri·ªáu ch·ª©ng b·ªánh l√Ω\n‚Ä¢ Th√¥ng tin ch·∫©n ƒëo√°n\n‚Ä¢ T√†i li·ªáu v√† kh√≥a h·ªçc y khoa\n\nH√£y ƒë·∫∑t c√¢u h·ªèi c·ª• th·ªÉ ƒë·ªÉ t√¥i h·ªó tr·ª£ t·ªët nh·∫•t!";
  }

  return "T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi c·ªßa b·∫°n. Vui l√≤ng cung c·∫•p th√™m th√¥ng tin chi ti·∫øt ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n m·ªôt c√°ch ch√≠nh x√°c nh·∫•t.";
}

// Event handlers
function handleSendMessage() {
  const text = userInput.value.trim();
  if (!text || isStreaming) {
    console.log('‚ö†Ô∏è Cannot send: empty message or streaming');
    return;
  }
  
  console.log('üí¨ User message:', text);
  addMessage(text, "user");
  userInput.value = "";
  
  sendMessage(text);
}

// Initialize everything when page loads
window.addEventListener('load', () => {
  console.log('üöÄ Page loaded, initializing...');
  
  // Test all elements
  testElements();
  
  // Set up click handler for chat icon
  if (chatIcon) {
    chatIcon.addEventListener('click', toggleChat);
    console.log('‚úÖ Chat icon click handler added');
  }
  
  // Set up send button
  if (sendBtn) {
    sendBtn.addEventListener('click', handleSendMessage);
    console.log('‚úÖ Send button click handler added');
  }
  
  // Set up enter key
  if (userInput) {
    userInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    });
    console.log('‚úÖ Input keydown handler added');
  }
  
  // Initialize chat as closed
  if (chatPopup) {
    chatPopup.style.display = 'none';
    isOpen = false;
    console.log('‚úÖ Chat initialized as closed');
  }
  
  console.log('üéâ Initialization complete!');
  console.log('üëÜ Click the blue icon in bottom-right corner to test!');
});

</script>

</body>
</html>